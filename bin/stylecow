#!/usr/bin/env node

var program = require('commander');
var inquirer = require('inquirer');
var clc = require('cli-color');
var stylecow = require('../lib');
var fs = require('fs');

var header = clc.cyan.bold;
var value = clc.yellow;
var error = clc.red.bold;
var success = clc.green.bold;


program
	.command('convert <input> [<output>]')
	.description('Convert the css code of a file')
	.option('-e, --explorer <version>', 'Min version supported in Internet Explorer instead the default', optionBrowser)
	.option('-f, --firefox <version>', 'Min version supported in Mozilla Firefox instead the default', optionBrowser)
	.option('-c, --chrome <version>', 'Min version supported in Google Chrome instead the default', optionBrowser)
	.option('-s, --safari <version>', 'Min version supported in Safari instead the default', optionBrowser)
	.option('-o, --opera <version>', 'Min version supported in Opera instead the default', optionBrowser)
	.option('-a, --android <version>', 'Min version supported in Android instead the default', optionBrowser)
	.option('-i, --ios <version>', 'Min version supported in Safari iOS instead the default', optionBrowser)
	.option('--code <style>', 'The code style used to generate the css (default|minify) instead the default')
	.option('--plugins <plugins>', 'Comma-separated list of plugins instead use the defaults', optionPlugins)
	.option('--plugins:add <plugins>', 'Comma-separated list of plugins used besides to the defaults', optionPlugins)
	.option('--plugins:remove <plugins>', 'Comma-separated list of default plugins that wont be used', optionPlugins)
	.action(convert);


program
	.command('plugin')
	.description('Manage the installed plugins')
	.option('-l, --list', 'List all installed plugins')
	.option('-i, --install <plugin>', 'Installs a new plugin', optionPlugins)
	.option('-u, --uninstall <plugin>', 'Uninstalls a plugin', optionPlugins)
	.action(plugin);


program
	.command('defaults')
	.description('Manages the default configurations values')
	.option('-l, --list', 'List all configuration values')
	.option('--explorer <version>', 'Changes the min version supported in Internet Explorer', optionBrowser)
	.option('--firefox <version>', 'Changes the min version supported in Mozilla Firefox', optionBrowser)
	.option('--chrome <version>', 'Changes the min version supported in Google Chrome', optionBrowser)
	.option('--safari <version>', 'Changes the min version supported in Safari', optionBrowser)
	.option('--opera <version>', 'Changes the min version supported in Opera', optionBrowser)
	.option('--android <version>', 'Changes the min version supported in Android', optionBrowser)
	.option('--ios <version>', 'Changes the min version supported in Safari iOS', optionBrowser)
	.option('--code <style>', 'Changes the code style used to generate the css (default|minify)', optionPlugins)
	.option('--plugins <plugins>', 'Changed the list of plugins used by default', optionPlugins)
	.option('--plugins:add <plugins>', 'Adds more plugins to be executed by default', optionPlugins)
	.option('--plugins:remove <plugins>', 'Removes plugins from the defaults', optionPlugins)
	.action(defaults);


program
	.command('create-manifest <file>')
	.description('Creates a manifest file for a css conversion')
	.action(create_manifest);


program.parse(process.argv);


//CONVERT
function convert (input, output, command) {
	var config = getConfig();

	modifyConfig(config, command, function (config) {
		stylecow.loadPlugins(config.plugins, function (loadedPlugins) {
			execute(input, output, loadedPlugins, config.support, config.code);
		});
	});
}

function execute (input, output, plugins, minSupport, codeStyle, watch) {
	var code = stylecow.readFile(input);
	code.executePlugins(plugins, minSupport);

	if (output) {
		fs.writeFileSync(output, code.toCode(codeStyle));
		console.log(success('CSS saved in "' + output + '"'));
	} else {
		console.log(code.toCode(codeStyle));
	}

	if (watch) {
		console.log(value('Waiting for changes'));
		
		var files = {};

		code
			.search()
			.filter(function (child) {
				return (child._data && child._data['sourceFile']);
			})
			.map(function (child) {
				return child._data['sourceFile'];
			})
			.forEach(function (file) {
				files[file] = null;
			});
		
		for (var file in files) {
			fs.watchFile(file, {persistent: true, interval: 2000}, function (curr, prev) {
				if (curr.mtime !== prev.mtime) {
					console.log(value('changed detected in "' + file + '"'));
					
					for (var f in files) {
						fs.unwatchFile(f);
					}

					execute(input, output, plugins, minSupport, codeStyle, watch);
				}
			});
		}
	}
}


//CONFIG

function defaults (command) {
	var config = getConfig();

	if (command.list) {
		console.log('');
		console.log(header('BROWSER SUPPORT:'));

		for (var browser in config.support) {
			console.log(browser + ':', value(config.support[browser]));
		}

		console.log('');
		console.log(header('PLUGINS:'));

		if (!config.plugins.length) {
			console.log('No default plugins');
		} else {
			config.plugins.forEach(function (plugin) {
				console.log('- ' + value(plugin));
			});
		}

		console.log('');
		console.log(header('CODE:'));

		for (var k in config.code) {
			console.log(k + ':', value('"' + config.code[k].replace('\n', '\\n').replace('\t', '\\t') + '"'));
		}

		return;
	}

	modifyConfig(config, command, function (config) {
		saveConfig(config);
	});
}

function create_manifest (file, command) {
	var config = getConfig();

	getInstalledPlugins(function (installed) {
		var pluginChoices = [];

		installed.forEach(function (plugin) {
			if (config.plugins.indexOf(plugin) === -1) {
				pluginChoices.push({
					key: plugin,
					name: plugin,
					value: plugin
				});
			} else {
				pluginChoices.push({
					key: plugin,
					name: plugin,
					value: plugin,
					checked: true
				});
			}
		});

		var questions = [
			{
				type: "input",
				name: "input",
				message: "The path of the css file to convert (optional)"
			},
			{
				type: "input",
				name: "output",
				message: "The path of the css file where the code will be saved (optional)"
			},
			{
				type: "input",
				name: "explorer",
				message: "Min version supported in Internet Explorer",
				default: config.support.explorer
			},
			{
				type: "input",
				name: "firefox",
				message: "Min version supported in Mozilla Firefox",
				default: config.support.firefox
			},
			{
				type: "input",
				name: "chrome",
				message: "Min version supported in Google Chrome",
				default: config.support.chrome
			},
			{
				type: "input",
				name: "safari",
				message: "Min version supported in Safari",
				default: config.support.safari
			},
			{
				type: "input",
				name: "opera",
				message: "Min version supported in Opera",
				default: config.support.opera
			},
			{
				type: "input",
				name: "android",
				message: "Min version supported in Android",
				default: config.support.android
			},
			{
				type: "input",
				name: "ios",
				message: "Min version supported in Safari for iOS",
				default: config.support.ios
			},
			{
				type: "list",
				name: "code",
				message: "Code style used to generate the css",
				choices: ['default', 'minify'],
				default: 'default'
			},
			{
				type: "checkbox",
				name: "plugins",
				message: "Plugins used to transform de css",
				choices: pluginChoices
			}
		];

		inquirer.prompt(questions, function (answers) {
			var manifest = {};

			if (answers.input) {
				manifest.input = answers.input;
			}

			if (answers.output) {
				manifest.output = answers.output;
			}

			manifest.support = {};

			['explorer','firefox','chrome','safari','opera','android','ios'].forEach(function (browser) {
				manifest.support[browser] = answers[browser];
			});

			manifest.code = stylecow.getCodeStyle(answers.code);
			manifest.plugins = answers.code;

			fs.writeFileSync(file, JSON.stringify(manifest, null, '\t'));
		});
	});
}



//PLUGIN

function plugin (command) {
	if (command.list) {
		getInstalledPlugins(function (plugins) {
			plugins.forEach(function (plugin) {
				console.log('- ' + value(plugin));
			});
		});

		return;
	}

	if (command.install) {
		loadNpm(function (npm) {
			var packages = [];

			command.install.forEach(function (plugin) {
				packages.push(stylecow.getPluginPackage(plugin));

			});

			npm.commands.install(packages, function (err, data) {
				if (!err) {
					console.log('');
					console.log(success('Plugins installed successfully!!'));
					console.log('');
				}
			});
		});
	}

	if (command.uninstall) {
		loadNpm(function (npm) {
			var packages = [];

			command.uninstall.forEach(function (plugin) {
				packages.push(stylecow.getPluginPackage(plugin));

			});

			npm.commands.uninstall(packages, function (err, data) {
				if (!err) {
					console.log('');
					console.log(success('Plugins uninstalled successfully!!'));
					console.log('');
				}
			});
		});
	}
}




// Misc

function modifyConfig (config, command, callback) {
	if (command.code) {
		config.code = stylecow.getCodeStyle(command.code);

		if (!config.code) {
			console.log(error('The code style ' + command.code + ' is not valid'));
		}
	}

	['explorer','firefox','chrome','safari','opera','android','ios'].forEach(function (browser) {
		if (command[browser]) {
			config.support[browser] = command[browser];
		}
	});

	if (command.plugins) {
		config.plugins = command.plugins;
	}

	if (command['plugins:remove']) {
		command['plugins:remove'].forEach(function (plugin) {
			var index = plugins.indexOf(plugin);

			if (index !== -1) {
				config.plugins.splice(index, 1);
			}
		});
	}

	if (command['plugins:add']) {
		getInstalledPlugins(function (installed) {
			command['plugins:add'].forEach(function (plugin) {
				if (installed.indexOf(plugin) === -1) {
					console.log(error("The plugin '" + plugin + "' is not installed. To install, execute `stylecow plugin install " + plugin + "`"));
				} else if (config.plugins.indexOf(plugin) === -1) {
					config.plugins.push(plugin);
				}
			});

			callback(config);
		});
	} else {
		callback(config);
	}
}

function optionBrowser (value) {
	if (value === 'false') {
		return false;
	}

	return parseFloat(value, 10);
}

function optionPlugins (value) {
	return value.split(',');
}

function loadNpm (callback) {
	var npm = require('npm');

	npm.load(function (err) {
		if (err) {
			console.log(error(err));
			return;
		}

		callback(npm);
	});
}

function getInstalledPlugins (callback) {
	loadNpm(function (npm) {
		var plugins = fs.readdirSync(npm.root).filter(function (value) {
			return value.slice(0, 16) === 'stylecow-plugin-';
		}).map(function (value) {
			return value.slice(16);
		});

		callback(plugins);
	});
}

function getConfig () {
	file = __dirname + '/../config/default.json';

	if (!fs.existsSync(file)) {
		return def;
	}

	return JSON.parse(fs.readFileSync(file, 'utf8'));
}

function saveConfig (value) {
	file = __dirname + '/../config/default.json';

	fs.writeFileSync(file, JSON.stringify(value, null, '\t'));
}
