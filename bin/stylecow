#!/usr/bin/env node

var program = require('commander');
var inquirer = require('inquirer');
var clc = require('cli-color');
var stylecow = require('../lib');
var fs = require('fs');
var path = require('path');
var glob = require('glob');

var header = clc.cyan.bold;
var value = clc.yellow;
var error = clc.red.bold;
var success = clc.green.bold;

var configFile = (process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE) + '/.stylecow_config.json';
var packageInfo = JSON.parse(fs.readFileSync(__dirname + '/../package.json', 'utf8'));

program.version(packageInfo.version);


program
	.command('convert <input> [<output>]')
	.usage('<input> [<output>] [options]')
	.description('Convert the css code of a file')
	.option('-w, --watch', 'Watches the changes in the css files')
	.option('--explorer <version>', 'Min version supported in Internet Explorer instead the default', optionBrowser)
	.option('--firefox <version>', 'Min version supported in Mozilla Firefox instead the default', optionBrowser)
	.option('--chrome <version>', 'Min version supported in Google Chrome instead the default', optionBrowser)
	.option('--safari <version>', 'Min version supported in Safari instead the default', optionBrowser)
	.option('--opera <version>', 'Min version supported in Opera instead the default', optionBrowser)
	.option('--android <version>', 'Min version supported in Android instead the default', optionBrowser)
	.option('--ios <version>', 'Min version supported in Safari iOS instead the default', optionBrowser)
	.option('--code <style>', 'The code style used to generate the css (default|minify) instead the default')
	.option('--plugins <plugins>', 'Comma-separated list of plugins instead use the defaults', optionPlugins)
	.option('--plugins:add <plugins>', 'Comma-separated list of plugins used besides to the defaults', optionPlugins)
	.option('--plugins:remove <plugins>', 'Comma-separated list of default plugins that wont be used', optionPlugins)
	.action(convert);


program
	.command('plugins')
	.description('Manage the installed plugins')
	.option('-l, --list', 'List all installed plugins')
	.option('-i, --install <plugin>', 'Installs new plugins', optionPlugins)
	.option('-r, --uninstall <plugin>', 'Uninstalls plugins', optionPlugins)
	.option('-u, --update', 'Update all installed plugins to the latest version')
	.option('-s, --search <plugin>', 'Search a specific plugin')
	.action(plugins);


program
	.command('defaults')
	.description('Manages the default configurations values')
	.option('-l, --list', 'List all configuration values')
	.option('--explorer <version>', 'Changes the min version supported in Internet Explorer', optionBrowser)
	.option('--firefox <version>', 'Changes the min version supported in Mozilla Firefox', optionBrowser)
	.option('--chrome <version>', 'Changes the min version supported in Google Chrome', optionBrowser)
	.option('--safari <version>', 'Changes the min version supported in Safari', optionBrowser)
	.option('--opera <version>', 'Changes the min version supported in Opera', optionBrowser)
	.option('--android <version>', 'Changes the min version supported in Android', optionBrowser)
	.option('--ios <version>', 'Changes the min version supported in Safari iOS', optionBrowser)
	.option('--code <style>', 'Changes the code style used to generate the css (default|minify)', optionPlugins)
	.option('--plugins <plugins>', 'Changed the list of plugins used by default', optionPlugins)
	.option('--plugins:add <plugins>', 'Adds more plugins to be executed by default', optionPlugins)
	.option('--plugins:remove <plugins>', 'Removes plugins from the defaults', optionPlugins)
	.action(defaults);


program
	.command('create-manifest <file>')
	.usage('<file>')
	.description('Creates a manifest file for a css conversion')
	.action(create_manifest);


//CONVERT
function convert (input, output, command) {
	var config = getConfig(true);

	modifyConfig(config, command, function (config) {
		stylecow.loadPlugins(config.plugins, function (loadedPlugins) {

			if (!fs.existsSync(input)) {
				console.log(error('The path "' + input + '" does not exists'));
				return;
			}

			if (fs.lstatSync(input).isFile()) {
				return execute(input, output, loadedPlugins, config.support, config.code, command.watch);
			}

			if (fs.lstatSync(input).isDirectory()) {
				return glob('**/*.css', {
						cwd: path.resolve(input)
					}, function (er, files) {
						files.forEach(function (file) {
							var finput = path.join(input, file);
							var foutput = output ? path.join(output, file) : null;

							execute(finput, foutput, loadedPlugins, config.support, config.code, command.watch);
						});
				});
			}
		});
	});
}


function execute (input, output, plugins, minSupport, codeStyle, watch) {
	var code = stylecow.readFile(input);
	code.executePlugins(plugins, minSupport);

	if (output) {
		var dir = path.dirname(output);

		if (!fs.existsSync(dir)) {
			fs.mkdirSync(dir);
		}

		fs.writeFileSync(output, code.toCode(codeStyle));
		console.log(success('Generated "' + output + '"'));
	} else {
		console.log(code.toCode(codeStyle));
	}

	if (watch) {
		console.log(value('Waiting for changes'));
		
		var files = {};

		code
			.search()
			.filter(function (child) {
				return (child._data && child._data['sourceFile']);
			})
			.map(function (child) {
				return child._data['sourceFile'];
			})
			.forEach(function (file) {
				files[file] = null;
			});
		
		for (var file in files) {
			fs.watchFile(file, {persistent: true, interval: 2000}, function (curr, prev) {
				if (curr.mtime !== prev.mtime) {
					console.log(value('changed detected in "' + file + '"'));
					
					for (var f in files) {
						fs.unwatchFile(f);
					}

					execute(input, output, plugins, minSupport, codeStyle, watch);
				}
			});
		}
	}
}


//CONFIG

function defaults (command) {
	showHelpOnEmpty('defaults', command);

	var config = getConfig();

	if (command.list) {
		console.log('');
		console.log(header('BROWSER SUPPORT:'));

		for (var browser in config.support) {
			console.log(browser + ':', value(config.support[browser]));
		}

		console.log('');
		console.log(header('PLUGINS:'));

		if (config.plugins.length) {
			config.plugins.forEach(function (plugin) {
				console.log('- ' + value(plugin));
			});
		} else {
			console.log('No plugins applied by default');
		}

		console.log('');
		console.log(header('CODE:'));

		for (var k in config.code) {
			console.log(k + ':', value('"' + config.code[k].replace('\n', '\\n').replace('\t', '\\t') + '"'));
		}

		return;
	}

	modifyConfig(config, command, function (config) {
		saveConfig(config);
	});
}


function create_manifest (file, command) {
	var config = getConfig();

	var pluginChoices = stylecow.getInstalledPlugins().map(function (plugin) {
		return {
			key: plugin,
			name: plugin,
			value: plugin,
			checked: (config.plugins.indexOf(plugin) !== -1)
		};
	});

	var questions = [
		{
			type: "input",
			name: "input",
			message: "The path of the css file to convert (optional)"
		},
		{
			type: "input",
			name: "output",
			message: "The path of the css file where the code will be saved (optional)"
		},
		{
			type: "input",
			name: "explorer",
			message: "Min version supported in Internet Explorer",
			default: config.support.explorer
		},
		{
			type: "input",
			name: "firefox",
			message: "Min version supported in Mozilla Firefox",
			default: config.support.firefox
		},
		{
			type: "input",
			name: "chrome",
			message: "Min version supported in Google Chrome",
			default: config.support.chrome
		},
		{
			type: "input",
			name: "safari",
			message: "Min version supported in Safari",
			default: config.support.safari
		},
		{
			type: "input",
			name: "opera",
			message: "Min version supported in Opera",
			default: config.support.opera
		},
		{
			type: "input",
			name: "android",
			message: "Min version supported in Android",
			default: config.support.android
		},
		{
			type: "input",
			name: "ios",
			message: "Min version supported in Safari for iOS",
			default: config.support.ios
		},
		{
			type: "list",
			name: "code",
			message: "Code style used to generate the css",
			choices: ['default', 'normal', 'minify'],
			default: 'default'
		},
		{
			type: "checkbox",
			name: "plugins",
			message: "Plugins used to transform de css",
			choices: pluginChoices
		}
	];

	inquirer.prompt(questions, function (answers) {
		var manifest = {};

		if (answers.input) {
			manifest.input = answers.input;
		}

		if (answers.output) {
			manifest.output = answers.output;
		}

		manifest.support = {};

		['explorer','firefox','chrome','safari','opera','android','ios'].forEach(function (browser) {
			manifest.support[browser] = optionBrowser(answers[browser]);
		});

		if (answers.code === 'default') {
			manifest.code = config.code;
		} else {
			manifest.code = stylecow.getCodeStyle(answers.code);
		}

		manifest.plugins = answers.plugins;

		var json = JSON.stringify(manifest, null, '\t');

		console.log(json);

		inquirer.prompt([
			{
				type: "confirm",
				name: "ok",
				message: "Looks fine?"
			}
		], function (answers) {
				if (answers.ok) {
					fs.writeFileSync(file, json);
					console.log(success('Manifest saved successfully in ' + file));
				}
		});

	});
}


//PLUGIN

function plugins (command) {
	showHelpOnEmpty('plugins', command);

	if (command.list) {
		var plugins = stylecow.getInstalledPlugins();

		if (plugins.length) {
			stylecow.getInstalledPlugins().forEach(function (plugin) {
				console.log('- ' + value(plugin));
			});
		} else {
			console.log('No installed plugins');
		}

		return;
	}

	if (command.search) {
		loadNpm(function (npm) {
			npm.commands.search([stylecow.pluginPrefix, command.search], function (err, data) {
				/*var i, plugin;

				for (i in data) {
					plugin = data[i];
					console.log(value(stylecow.getPluginName(plugin.name)));
					console.log(plugin.description);
					console.log(plugin.version, plugin.author, plugin.date);
					console.log('')
				}*/
			});
		});

		return;
	}

	var config = getConfig();

	if (command.install) {
		installPlugins(command.install, function () {
			console.log('');
			console.log(success('Plugins installed successfully!!'));
			console.log('');
		});
	}

	if (command.uninstall) {
		uninstallPlugins(command.uninstall, function () {
			console.log('');
			console.log(success('Plugins uninstalled successfully!!'));
			console.log('');
		});
	}

	if (command.update) {
		updatePlugins(stylecow.getInstalledPlugins(), function () {
			console.log('');
			console.log(success('Plugins updated successfully!!'));
			console.log('');
		});
	}

	saveConfig(config);
}


// Misc

function showHelpOnEmpty (name, command) {
	var l = program.rawArgs.length - 1;

	if (program.rawArgs[l] === name) {
		command.help();
	}
}

function modifyConfig (config, command, callback) {
	if (command.code) {
		config.code = stylecow.getCodeStyle(command.code);

		if (!config.code) {
			console.log(error('The code style ' + command.code + ' is not valid'));
		}
	}

	['explorer','firefox','chrome','safari','opera','android','ios'].forEach(function (browser) {
		if (command[browser]) {
			config.support[browser] = command[browser];
		}
	});

	if (command.plugins) {
		config.plugins = command.plugins;
	}

	if (command['plugins:remove']) {
		command['plugins:remove'].forEach(function (plugin) {
			var index = plugins.indexOf(plugin);

			if (index !== -1) {
				config.plugins.splice(index, 1);
			}
		});
	}

	if (command['plugins:add']) {
		command['plugins:add'].forEach(function (plugin) {
			if (config.plugins.indexOf(plugin) === -1) {
				config.plugins.push(plugin);
			}
		});
	}

	var installed = stylecow.getInstalledPlugins();
	var notInstalled = config.plugins.filter(function (plugin) {
		return installed.indexOf(plugin) === -1;
	});

	if (notInstalled.length) {
		inquirer.prompt([
			{
				type: "confirm",
				name: "install",
				message: "The following plugins are not installed. Do you want install them now? \n" + value(notInstalled.join(', '))
			}
		], function (answers) {
			if (answers.install) {
				installPlugins(notInstalled, function () {
					console.log(success('Plugins installed!'));
					callback(config);
				});
			} else {
				callback(config);
			}
		});
	} else {
		callback(config);
	}
}

function optionBrowser (value) {
	if (value === 'false') {
		return false;
	}

	return parseFloat(value, 10);
}

function optionPlugins (value) {
	return value.split(',');
}

function loadNpm (callback) {
	var npm = require('npm');

	npm.load({
		prefix: path.dirname(__dirname)
	}, function (err) {
		if (err) {
			console.log(error(err));
			return;
		}

		callback(npm);
	});
}

function installPlugins (plugins, callback) {
	loadNpm(function (npm) {
		var packages = plugins.map(function (plugin) {
			return stylecow.getPluginPackage(plugin);
		});

		npm.commands.install(packages, function (err, data) {
			if (!err) {
				callback();
			}
		});
	});
}

function uninstallPlugins (plugins, callback) {
	loadNpm(function (npm) {
		var packages = plugins.map(function (plugin) {
			return stylecow.getPluginPackage(plugin);
		});

		npm.commands.uninstall(packages, function (err, data) {
			if (!err) {
				callback();
			}
		});
	});
}

function updatePlugins (plugins, callback) {
	loadNpm(function (npm) {
		var packages = plugins.map(function (plugin) {
			return stylecow.getPluginPackage(plugin);
		});

		npm.commands.update(packages, function (err, data) {
			if (!err) {
				callback();
			}
		});
	});
}

function getConfig (asManifest) {
	if (fs.existsSync(configFile)) {
		return JSON.parse(fs.readFileSync(configFile, 'utf8'));
	}

	return stylecow.getDefaults();
}

function saveConfig (value) {
	fs.writeFileSync(configFile, JSON.stringify(value, null, '\t'));
}

program.parse(process.argv);

if (program.args.length === 0) {
	program.help();
}
